<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FELICES 25</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 24px; max-width: 820px; }
    h1 { margin: 0 0 8px; }
    .muted { color: #555; }
    .row { display: flex; gap: 8px; margin: 16px 0; }
    input { flex: 1; padding: 10px; font-size: 16px; }
    button { padding: 10px 14px; font-size: 16px; cursor: pointer; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 14px; margin-top: 14px; }
    .heatbar { height: 10px; background: #eee; border-radius: 999px; overflow: hidden; margin-top: 8px; }
    .heatfill { height: 100%; width: 0%; background: #111; transition: width 200ms ease; }
    ul { padding-left: 18px; }
    li { margin: 8px 0; }
    .ok { font-weight: 700; }
    .small { font-size: 13px; color: #666; }
    .pill { display:inline-block; padding: 3px 8px; border:1px solid #ddd; border-radius:999px; font-size:12px; margin-left:8px; }

    /* Mapa (solo polígonos) */
    #map {
      height: 420px;
      margin-top: 14px;
      border: 1px solid #ddd;
      border-radius: 10px;
      background: #fff;
    }
  </style>
</head>
<body>
  <h1>FELICES 25. <span class="pill">viaje sorpresa</span></h1>
  <div class="muted">
    Para celebrar este gran año que viene nos vamos a ir de viaje. Como se que te encantan las adivinanzas, aqui tienes el juego para ganarte los billetes de vuelo.
    <br><br>
    Muy sencillo. Introduce nombres de paises, y estos apareceran de color mas calido si estan cerca del destino, y al contrario si se encuentran lejos.
    <br><br>
    Suerte!
  </div>

  <datalist id="countriesList"></datalist>

  <!-- Contenedor del mapa -->
  <div id="map"></div>

  <div class="card">
    <div><span class="ok" id="status">Cargando países…</span></div>
    <div class="heatbar"><div class="heatfill" id="heatfill"></div></div>
    <div class="small" id="hint"></div>
  </div>

  <div class="card">
    <div class="ok">Intentos</div>
    <ul id="attempts"></ul>
    <button id="btnReset" style="margin-top:10px;">Reiniciar</button>
    <div class="small">Se guarda el progreso en este navegador.</div>
  </div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
(() => {
  "use strict";

  // ===================== CONFIG =====================
  // Hungría (Hungary) alpha3 = "HUN"
  // Base64("HUN") = "SFVO"
  const TARGET_ALPHA3_B64 = "SFVO";
  const WIN_TEXT = "Correcto. Este es tu destino.";
  const STORAGE_KEY = "guess-the-country-v1";
  // ==================================================

  const $guess = document.getElementById("guess");
  const $btnTry = document.getElementById("btnTry");
  const $btnReset = document.getElementById("btnReset");
  const $status = document.getElementById("status");
  const $hint = document.getElementById("hint");
  const $attempts = document.getElementById("attempts");
  const $list = document.getElementById("countriesList");
  const $heat = document.getElementById("heatfill");

  const TARGET_ALPHA3 = atob(TARGET_ALPHA3_B64).trim().toUpperCase();

  let countries = []; // { name, a3, lat, lon }
  let target = null;
  let attempts = [];  // { name, km, dir }

  // ===== MAPA =====
  let map = null;
  let layerByA3 = new Map(); // alpha3 -> array de layers Leaflet

  function norm(s) {
    return (s || "")
      .trim()
      .toLowerCase()
      .normalize("NFD")
      .replace(/\p{Diacritic}/gu, "");
  }

  function haversineKm(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const toRad = d => d * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
      Math.sin(dLat/2) ** 2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) ** 2;
    return 2 * R * Math.asin(Math.sqrt(a));
  }

  function direction(lat1, lon1, lat2, lon2) {
    const toRad = d => d * Math.PI / 180;
    const toDeg = r => r * 180 / Math.PI;
    const φ1 = toRad(lat1), φ2 = toRad(lat2);
    const λ1 = toRad(lon1), λ2 = toRad(lon2);
    const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
    const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
    const brng = (toDeg(Math.atan2(y, x)) + 360) % 360;
    const dirs = ["N","NE","E","SE","S","SW","W","NW"];
    return dirs[Math.round(brng / 45) % 8];
  }

  function heat01(km) {
    const max = 8000;
    return Math.max(0, Math.min(1, 1 - km / max));
  }

  function setHeat(km) {
    $heat.style.width = Math.round(heat01(km) * 100) + "%";
  }

  function renderAttempts() {
    $attempts.innerHTML = "";
    for (const a of attempts) {
      const li = document.createElement("li");
      li.textContent = `${a.name} — ${a.km.toFixed(0)} km (${a.dir})`;
      $attempts.appendChild(li);
    }
  }

  function save() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ attempts }));
  }

  function load() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const data = JSON.parse(raw);
      attempts = Array.isArray(data.attempts) ? data.attempts : [];
    } catch {
      attempts = [];
    }
  }

  function findCountryByName(input) {
    const n = norm(input);
    if (!n) return null;

    // exact
    let c = countries.find(x => norm(x.name) === n);
    if (c) return c;

    // aliases mínimos
    const aliases = new Map([
      ["usa", "united states"],
      ["estados unidos", "united states"],
      ["eeuu", "united states"],
      ["uk", "united kingdom"],
      ["reino unido", "united kingdom"],
      ["hungria", "hungary"],
    ]);
    if (aliases.has(n)) {
      const nn = aliases.get(n);
      c = countries.find(x => norm(x.name) === norm(nn));
      if (c) return c;
    }

    // startsWith
    return countries.find(x => norm(x.name).startsWith(n)) || null;
  }

  function checkWin(guessCountry) {
    return guessCountry.a3 === target.a3;
  }

  // ===== MAP HELPERS =====
  function heatColor(km) {
    // 0km -> rojo; 8000km+ -> azul
    const max = 8000;
    const t = Math.max(0, Math.min(1, 1 - km / max));
    const hue = 240 - 240 * t; // azul->rojo
    return `hsl(${hue}, 80%, 50%)`;
  }

  function paintCountry(a3, km) {
    const layers = layerByA3.get(a3);
    if (!layers) return;

    const style = {
      fillColor: heatColor(km),
      fillOpacity: 0.85,
      color: "#444",
      weight: 1
    };
    for (const lyr of layers) lyr.setStyle(style);
  }

  function getA3FromFeatureProps(props) {
    if (!props) return "";
    // Probamos varias claves comunes
    return (
      props["ISO3166-1-Alpha-3"] ||
      props["ISO_A3"] ||
      props["ADM0_A3"] ||
      props["iso_a3"] ||
      props["id"] ||
      ""
    ).toString().toUpperCase();
  }

  async function initMap() {
    // Mapa sin tiles: fondo blanco + polígonos
    map = L.map("map", {
      zoomControl: true,
      attributionControl: false,
      minZoom: 1,
      maxZoom: 6
    }).setView([20, 0], 2);

    const url = "./world.geojson?v=" + Date.now();
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status + " al cargar " + url + " (sube world.geojson a la raíz)");

    const gj = await res.json();
    layerByA3 = new Map();

    L.geoJSON(gj, {
      style: () => ({
        fillColor: "#eee",
        fillOpacity: 0.55,
        color: "#999",
        weight: 1
      }),
      onEachFeature: (feature, layer) => {
        const a3 = getA3FromFeatureProps(feature && feature.properties ? feature.properties : {});
        if (!a3) return;

        if (!layerByA3.has(a3)) layerByA3.set(a3, []);
        layerByA3.get(a3).push(layer);
      }
    }).addTo(map);

    // Si ya sabemos el destino, lo resaltamos suavemente (opcional y discreto)
    // paintCountry(TARGET_ALPHA3, 0);
  }

  async function init() {
    $status.textContent = "Descargando países…";
    $hint.textContent = "";

    const url = "./countries.json?v=" + Date.now(); // rompe caché
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error("HTTP " + res.status + " al cargar " + url);

    $status.textContent = "Procesando países…";
    const text = await res.text();
    const cleaned = text.replace(/^\uFEFF/, ""); // elimina BOM si existe
    const parsed = JSON.parse(cleaned);

    // 1) Encuentra la lista real de países dentro del JSON (sea array directo o esté envuelto)
    let list = [];

    if (Array.isArray(parsed)) {
      list = parsed;
    } else if (parsed && typeof parsed === "object") {
      const candidates = [parsed.countries, parsed.data, parsed.items, parsed.results];
      const firstArrayCandidate = candidates.find(v => Array.isArray(v));
      if (firstArrayCandidate) {
        list = firstArrayCandidate;
      } else {
        const arrays = Object.values(parsed).filter(v => Array.isArray(v));
        if (arrays.length) list = arrays[0];
      }
    }

    if (Array.isArray(list) && list.length && Array.isArray(list[0])) {
      list = list.flat();
    }

    if (!Array.isArray(list) || !list.length) {
      throw new Error("countries.json no trae una lista válida de países (no se encontró ningún array utilizable)");
    }

    // 2) Construye countries de forma tolerante a campos
    function pick(obj, keys) {
      for (const k of keys) {
        if (obj && obj[k] != null) return obj[k];
      }
      return null;
    }

    countries = list
      .map(x => {
        const name = pick(x, ["country", "name", "Country"]);
        const a3 = pick(x, ["alpha3", "alpha_3", "cca3", "iso3", "ISO3166-1-Alpha-3"]) || "";
        const lat = Number(pick(x, ["latitude", "lat", "Latitude"]));
        const lon = Number(pick(x, ["longitude", "lon", "lng", "long", "Longitude"]));
        return {
          name: name ? String(name) : "",
          a3: String(a3).toUpperCase(),
          lat,
          lon
        };
      })
      .filter(c => c.name && c.a3 && Number.isFinite(c.lat) && Number.isFinite(c.lon));

    if (!countries.length) {
      throw new Error("No se pudo construir la lista de países desde countries.json (campos no coinciden)");
    }

    // Autocomplete
    $list.innerHTML = "";
    for (const c of countries) {
      const opt = document.createElement("option");
      opt.value = c.name;
      $list.appendChild(opt);
    }

    target = countries.find(x => x.a3 === TARGET_ALPHA3);
    if (!target) throw new Error("No encuentro el destino (alpha3=" + TARGET_ALPHA3 + ") en countries.json");

    // Inicializa mapa (requiere world.geojson en la raíz)
    $status.textContent = "Cargando mapa…";
    await initMap();

    load();
    renderAttempts();

    if (attempts.length === 0) {
      $status.textContent = "Listo. Empieza a probar países.";
      $hint.textContent = "Te diré distancia aproximada y dirección.";
      setHeat(8000);
    } else {
      const last = attempts[attempts.length - 1];
      $status.textContent = "Partida cargada. Sigue.";
      $hint.textContent = `Último intento: ${last.km.toFixed(0)} km (${last.dir}).`;
      setHeat(last.km);
    }
  }

  function onTry() {
    if (!target || countries.length === 0) return;

    const input = $guess.value;
    const g = findCountryByName(input);

    if (!g) {
      $status.textContent = "No reconozco ese país. Prueba con un nombre del desplegable.";
      return;
    }

    if (attempts.some(a => norm(a.name) === norm(g.name))) {
      $status.textContent = "Ese país ya lo probaste.";
      return;
    }

    const km = haversineKm(g.lat, g.lon, target.lat, target.lon);
    const dir = direction(g.lat, g.lon, target.lat, target.lon);

    // Pinta el país adivinado según cercanía
    paintCountry(g.a3, km);

    attempts.push({ name: g.name, km, dir });
    save();
    renderAttempts();
    setHeat(km);

    if (checkWin(g)) {
      $status.textContent = WIN_TEXT;
      $hint.textContent = `Destino: ${target.name}.`;

      // Zoom al país acertado (si existe layer)
      const layers = layerByA3.get(g.a3);
      if (layers && layers[0] && map) {
        map.fitBounds(layers[0].getBounds(), { padding: [20, 20] });
      }

      $guess.disabled = true;
      $btnTry.disabled = true;
    } else {
      $status.textContent = "Aún no. Sigue.";
      $hint.textContent = `${km.toFixed(0)} km (${dir}).`;
      $guess.value = "";
      $guess.focus();
    }
  }

  function onReset() {
    attempts = [];
    save();
    renderAttempts();
    $guess.disabled = false;
    $btnTry.disabled = false;
    $status.textContent = "Reiniciado. Empieza a probar países.";
    $hint.textContent = "";
    setHeat(8000);

    // Nota: no reseteamos colores del mapa para mantenerlo simple
    // Si quieres resetear, habría que recrear la capa o guardar estilos originales.
  }

  $btnTry.addEventListener("click", onTry);
  $guess.addEventListener("keydown", (e) => { if (e.key === "Enter") onTry(); });
  $btnReset.addEventListener("click", onReset);

  init().catch(err => {
    $status.textContent = "Error cargando el juego: " + (err && err.message ? err.message : String(err));
    $hint.textContent = "Si persiste, prueba en incógnito o con recarga fuerte (Ctrl+F5).";
    console.error(err);
  });
})();
</script>
</body>
</html>
